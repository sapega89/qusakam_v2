extends Node

#const Scatter2D := preload("../scatter2d.gd")
#const ScatterItem := preload("../scatter_item.gd")
const ModifierStack := preload("../stack/modifier_stack.gd")


# Make sure the output node exists. This is the parent node to
# everything generated by the scatter mesh
static func ensure_output_root_exists(s: Scatter2D) -> void:
	# Check if the node exists in the tree
	if not s.output_root:
		s.output_root = s.get_node_or_null("ScatterOutput")

	# If the node is valid, end here
	if is_instance_valid(s.output_root) and s.has_node(NodePath(s.output_root.name)):
		enforce_output_root_owner(s)
		return

	# Some conditions are not met, cleanup and recreate the root
	if s.output_root:
		if s.has_node(NodePath(s.output_root.name)):
			s.remove_node(s.output_root.name)
		s.output_root.queue_free()
		s.output_root = null

	s.output_root = Marker2D.new()
	s.output_root.name = "ScatterOutput"
	s.add_child(s.output_root, true)

	enforce_output_root_owner(s)


static func enforce_output_root_owner(s: Scatter2D) -> void:
	if is_instance_valid(s.output_root) and s.is_inside_tree():
		if s.show_output_in_tree:
			set_owner_recursive(s.output_root, s.get_tree().get_edited_scene_root())
		else:
			set_owner_recursive(s.output_root, null)

		# TMP: Workaround to force the scene tree to update and take in account
		# the owner changes. Otherwise it doesn't show until much later.
		s.output_root.update_configuration_warnings()



static func get_or_create_item_root(item: ScatterItem) -> Node2D:
	var s: Scatter2D = item.get_parent()
	ensure_output_root_exists(s)
	var item_root: Node2D = s.output_root.get_node_or_null(NodePath(item.name))

	if not item_root:
		item_root = Node2D.new()
		item_root.name = item.name
		item_root.y_sort_enabled = s.enable_y_sorting
		s.output_root.add_child(item_root, true)

		if Engine.is_editor_hint():
			item_root.owner = item.get_tree().get_edited_scene_root()

	return item_root



static func get_all_mesh_instances_from(node: Node) -> Array[MeshInstance2D]:
	var res: Array[MeshInstance2D] = []

	if node is MeshInstance2D:
		res.push_back(node)

	for c in node.get_children():
		res.append_array(get_all_mesh_instances_from(c))

	return res



static func get_final_material(item: ScatterItem, mi: MeshInstance2D) -> Material:
	if item.override_material:
		return item.override_material

	if mi.material_override:
		return mi.material_override

	if mi.get_surface_override_material(0):
		return mi.get_surface_override_material(0)

	return null



static func get_or_create_multimesh(item: ScatterItem, count: int) -> MultiMeshInstance2D:
	var item_root := get_or_create_item_root(item)
	var mmi: MultiMeshInstance2D = item_root.get_node_or_null("MultiMeshInstance2D")

	if not mmi:
		mmi = MultiMeshInstance2D.new()
		mmi.set_name("MultiMeshInstance2D")
		item_root.add_child(mmi, true)
		mmi.set_owner(item_root.owner)

	if not mmi.multimesh:
		mmi.multimesh = MultiMesh.new()

	var mesh_instance: MeshInstance2D = get_merged_meshes_from(item)
	if not mesh_instance:
		return

	mmi.position = Vector2.ZERO
	mmi.texture = mesh_instance.texture

	mmi.multimesh.instance_count = 0 # Set this to zero or you can't change the other values
	mmi.multimesh.mesh = mesh_instance.mesh
	mmi.multimesh.transform_format = MultiMesh.TRANSFORM_2D
	mmi.multimesh.instance_count = count

	mesh_instance.queue_free()
	return mmi


static func request_parent_to_rebuild(node: Node, deferred := true) -> void:
	var parent = node.get_parent()
	if not parent or not parent.is_inside_tree():
		return

	if parent and parent is Scatter2D:
		if not parent.is_ready:
			return

		if deferred:
			parent.rebuild.call_deferred(true)
		else:
			parent.rebuild(true)


static func get_all_static_bodies_from(node: Node) -> Array[StaticBody2D]:
	var res: Array[StaticBody2D] = []

	if node is StaticBody2D:
		res.push_back(node)

	for c in node.get_children():
		res.append_array(get_all_static_bodies_from(c))

	return res


# Grab every static bodies from the source item and merge them in a single
# one with multiple collision shapes.
static func get_collision_data(item: ScatterItem) -> StaticBody2D:
	var static_body := StaticBody2D.new()
	var source: Node2D = item.get_item()
	if not is_instance_valid(source):
		return static_body

	source.transform = Transform2D()

	for body in get_all_static_bodies_from(source):
		for child in body.get_children():
			if child is CollisionShape2D:
				# Don't use reparent() here or the child transform gets reset.
				body.remove_child(child)
				child.owner = null
				static_body.add_child(child)

	source.queue_free()
	return static_body



static func set_owner_recursive(node: Node, new_owner) -> void:
	node.set_owner(new_owner)

	if not node.get_scene_file_path().is_empty():
		return # Node is an instantiated scene, don't change its children owner.

	for c in node.get_children():
		set_owner_recursive(c, new_owner)



static func get_or_create_particles(item: ScatterItem) -> GPUParticles2D:
	var item_root := get_or_create_item_root(item)
	var particles: GPUParticles2D = item_root.get_node_or_null("GPUParticles2D")

	if not particles:
		particles = GPUParticles2D.new()
		particles.set_name("GPUParticles2D")
		item_root.add_child(particles)
		particles.set_owner(item_root.owner)

	var mesh_instance: MeshInstance2D = get_merged_meshes_from(item)
	if not mesh_instance:
		return

	#var shader_material = ShaderMaterial.new()
	#shader_material.shader = preload("../particles/static.gdshader")

	#particles.process_material = shader_material
	#particles.material_override = get_final_material(item, mesh_instance)
	#particles.set_draw_pass_mesh(0, mesh_instance.mesh)
	particles.texture = mesh_instance.texture
	particles.position = Vector2.ZERO
	particles.local_coords = true
	#particles.layers = item.visibility_layers

	# Use the user provided material if it exists.
	var process_material: Material = item.override_process_material

	# Or load the default one if there's nothing.
	if not process_material:
		process_material = ShaderMaterial.new()
		process_material.shader = preload("../particles/static.gdshader")

	if process_material is ShaderMaterial:
		process_material.set_shader_parameter("global_transform", item_root.get_global_transform())

	particles.set_process_material(process_material)

	# TMP: Workaround to get infinite life time.
	# Should be fine, but extensive testing is required.
	# I can't get particles to restart when using emit_particle() from a script, so it's either
	# that, or encoding the transform array in a texture an read that data from the particle
	# shader, which is significantly harder.
	particles.lifetime = 1.79769e308

	# Kill previous particles or new ones will not spawn.
	particles.restart()

	return particles


static func get_merged_meshes_from(item: ScatterItem) -> MeshInstance2D:
	if not item:
		return null

	var source: Node = item.get_item()
	if not is_instance_valid(source):
		return null

	source.transform = Transform2D()

	# get all the mesh instances
	var mesh_instances: Array[MeshInstance2D] = get_all_mesh_instances_from(source)
	source.queue_free()

	if mesh_instances.is_empty():
		return null

	var st := SurfaceTool.new()
	st.begin(Mesh.PRIMITIVE_TRIANGLES)

	var index_offset := 0

	for mi in mesh_instances:
		if not is_instance_valid(mi) or not is_instance_valid(mi.mesh):
			continue

		var mesh := mi.mesh as ArrayMesh
		for s in range(mesh.get_surface_count()):
			var arrays := mesh.surface_get_arrays(s)
			var verts: PackedVector3Array = arrays[Mesh.ARRAY_VERTEX]
			var uvs: PackedVector2Array = arrays[Mesh.ARRAY_TEX_UV]
			var cols: PackedColorArray   = arrays[Mesh.ARRAY_COLOR]
			var inds: PackedInt32Array   = arrays[Mesh.ARRAY_INDEX]

			for v in verts:
				var v2 := Vector2(v.x, v.y)
				v2 = mi.global_transform * v2
				st.add_vertex(Vector3(v2.x, v2.y, 0))

			for uv in uvs:
				st.add_uv(uv)

			for col in cols:
				st.add_color(col)

			for i in inds:
				st.add_index(i + index_offset)

			index_offset += verts.size()

	var merged_mesh := st.commit()
	var merged_instance := MeshInstance2D.new()
	merged_instance.mesh = merged_mesh
	return merged_instance


static func get_aabb_from_transforms(transforms : Array) -> Rect2:
	if transforms.size() < 1:
		return Rect2(Vector2.ZERO, Vector2.ZERO)
	var aabb = Rect2(transforms[0].origin, Vector2.ZERO)
	for t in transforms:
		aabb = aabb.expand(t.origin)
	return aabb


static func get_position_and_normal_at(curve: Curve2D, offset: float) -> Array:
	if not curve:
		return []

	var pos: Vector2 = curve.sample_baked(offset)
	var normal := Vector2.ZERO

	var pos1
	if offset + curve.get_bake_interval() < curve.get_baked_length():
		pos1 = curve.sample_baked(offset + curve.get_bake_interval())
		normal = (pos1 - pos)
	else:
		pos1 = curve.sample_baked(offset - curve.get_bake_interval())
		normal = (pos - pos1)

	return [pos, normal]


static func remove_line_breaks(text: String) -> String:
	# Remove tabs
	text = text.replace("\t", "")
	# Remove line breaks
	text = text.replace("\n", " ")
	# Remove occasional double space caused by the line above
	return text.replace("  ", " ")
